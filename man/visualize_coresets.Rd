% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/visualize_coreset.R
\name{visualize_coresets}
\alias{visualize_coresets}
\title{Function for visualizing Bayesian coresets}
\usage{
visualize_coresets(
  coreset_results,
  x,
  y,
  legend_true_label = TRUE,
  legend_weights = TRUE,
  name_variables = NA,
  equation_line = NA,
  intercept_col = 3
)
}
\arguments{
\item{coreset_results}{a list returned by either
\code{\link{get_coreset_uniform}} or \code{\link{get_coreset_frankwolfe}}.}

\item{x}{the original, full feature matrix.}

\item{y}{the vector of binary response variables.}

\item{legend_true_label}{(optional) boolean, set to FALSE to omit plot's
legend for the true class label. Default is TRUE.}

\item{legend_weights}{(optional) boolean, set to FALSE to omit the plot's
legend for the coreset weights. Default is TRUE.}

\item{name_variables}{(optional) a vector of length 2 containing the
desired axes labels. Default is c(expression(x[1]), expression(x[2])).}

\item{equation_line}{(optional) a vector of length 2 specifying the
intercept and slope of the linear classification boundary to draw on the
plot. The first element of the vector is the line's intercept, and the second
element is the line's slope.}

\item{intercept_col}{(optional) an integer specifying the column index for
the intercept column. Set to NA if model does not have an intercept.
Default is the last column, i.e. x[, 3], which is the default of
\code{\link{simulate_logit_data}}.}
}
\value{
a ggplot which visualizes the points selected for the coreset from
  the original data
}
\description{
This function visualizes coresets for binary response data. Note that these
  visualizations are limited to models with two covariates
  (not counting the intercept). Looking at these visualizations helps to
  understand the behavior of the two methods of obtaining coresets.
}
\examples{
# Setup data and sample coreset
data <- simulate_logit_data()
coreset_results <- get_coreset_uniform(data$x, data$y)

# Using all defaults
visualize_coresets(coreset_results, data$x, data$y)

# Omit class label from legend
visualize_coresets(coreset_results, data$x, data$y,
legend_true_label = FALSE)

# Omit coreset weights from legend
visualize_coresets(coreset_results, data$x, data$y, legend_weights = FALSE)

# Customize axes labels
visualize_coresets(coreset_results, data$x, data$y,
name_variables = c("first variable", "second variable"))

# Add glm equation results to plot
y_glm <- (data$y + 1) /2 # recode for glm call
glm_estimates <- glm(y_glm ~ data$x[, 1] + data$x[, 2], family = "binomial")
coeffs <- glm_estimates$coefficients
intercept <- - coeffs[1] / coeffs[3]
slope <- - coeffs[2] / coeffs[3]
visualize_coresets(coreset_results, data$x, data$y, equation_line = c(intercept, slope))

# No intercept example
data <- simulate_logit_data(params = list(intercept = FALSE,
theta = c(3, 3)))
coreset_results <- get_coreset_uniform(data$x, data$y)
visualize_coresets(coreset_results, data$x, data$y, intercept_col = NA)
}
